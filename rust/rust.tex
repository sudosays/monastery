\documentclass[12pt,notitlepage]{article}

\usepackage{hyperref}
\hypersetup{colorlinks = true, linkcolor = blue}

\usepackage{graphicx}
\graphicspath{{.images/}}

\usepackage{listings}
\usepackage{color}

\definecolor{mygray}{rgb}{0.5,0.5,0.5}


\lstset{basicstyle=\footnotesize\ttfamily}

% To use glossaries uncomment below

%\usepackage[toc]{glossaries}
%\makeglossaries
%\include{<glossaryfilename>}

\begin{document}

\title{Rust Programming Language}
\author{}
\date{}
\maketitle

%\tableofcontents
%\newpage

These notes are made from studying this
\href{https://doc.rust-lang.org/book/title-page.html}{book} 

\section{Hello World}

All Rust programs must feature a main function defined by

\begin{lstlisting}
fn main() {}
\end{lstlisting}


\subsection{Compilation}

Compiling is done using the rustc command and supplying the file containing the
main function

\section{Cargo}

Cargo is a useful tool for project creation and dependency management.

\subsection{Starting new projects}

Using \lstinline{cargo new <name>} automatically creates a new dir and
initialises a git repo in it. In the new repo you will find the following:

\begin{itemize}
    \item Cargo.toml
    \item .gitignore
    \item src
        \begin{itemize}
            \item main.rs
        \end{itemize}
\end{itemize}

\subsection{Cargo.toml}

The Cargo.toml file is a configuration file for the project written in Toms
Obvious Minimal Language.

It specifies a Rust package or \emph{crate}.

Cargo expects all code to live within the src directory and all of the
configuration, README, and licenses to live in the top-level directory.

\subsection{Building with Cargo}

Cargo has three different commands to check, build, and run the Rust code
called \lstinline{check}, \lstinline{build}, and \lstinline{run}.

Cargo check doesn't actually build a runnable executable, but does a quick
check to see if your code will compile. Build on the other hand actually
creates a binary executable and places it in the target/debug folder. Finally,
run builds and then runs the code from the target/debug folder.

Should you wish to release a binary executable, adding the flag
\lstinline{--release} to the build command will build a release version that
has been optimised thoroughly.

%\appendix




\subsection{Adding Dependencies}

With the Cargo.toml file you can easily add library crates to your project by
listing them under the ``dependencies'' section. It is necessary to specify the
crate name as well as providing a \emph{semantic version} number. For example,
if we were to add the \lstinline{rand} library we could do it like this:

\begin{lstlisting}
[dependencies]

rand = "0.3.14"
\end{lstlisting}

When this has been added to the Cargo.toml file, running build, check, or run
will cause cargo to automatically look up the rand library on the crates.io
registry. Then it'll pull the library as well as any of its dependencies before
compiling your crate.


\subsection{Updating dependency versions}

Running \lstinline{cargo update} will ignore the Cargo.lock file and attempt to
update the version number of the dependencies. However, it will only update the
patch versions and not the minor versions. For example, given a version 1.2.1
and there are two new versions 1.2.2 and 1.3.0. Cargo will update to 1.2.2 and
not 1.3.0 because it will not automatically bump the minor version number.
Therefore, you need to manually bump any dependencies if you wish to use a
newer minor/major version.

\subsection{Cargo.lock file}

For people familiar with the Python Pip system, the Cargo.lock file works
similarly to a requirements.txt, but is created and maintained automatically by
cargo. When the crate is first built it will ``lock'' all of the versions for
the dependencies which ensures that the crate will always build regardless of
the dependencies updating with breaking changes. These versions will not update
unless you explicitly run \lstinline{cargo update} or manually edit the
versions in the Cargo.toml file.

\section{Variable Assignment and Referencing}

Variables and references are immutable by default. Variable assignment is
achieved by using the \lstinline{let} keyword. Should you want a mutable
variable you add the \lstinline{mut} keyword after \lstinline{let} but before
the variable name. For example:

\begin{lstlisting}
let steadfast = true; //immutable

let mut wavering = true; //mutable
wavering = false;

\end{lstlisting}

Similarly, references are also immutable by default.

\begin{lstlisting}
&wavering // immutable

&mut wavering // mutable
\end{lstlisting}

\subsection{Specifying type}

A specific type for a variable can be denoted using the \lstinline{:}
syntax. For example declaring a unsigned 32-bit integer looks something like
this:

\begin{lstlisting}
let x: u32 = 1
\end{lstlisting}



\section{Associated functions}

The double colon syntax denotes calling an \emph{associated function} meaning
it is linked to a type and not an instance. That also means it does not need an
instance to be called. For example, the \lstinline{String} type has an
associated function \lstinline{::new()} which returns a new instance of the
string type.

\section{Reading from \lstinline{stdio}}

The standard library contains an io module which can be used to create an
instance of \lstinline{std::io::Stdin} by calling the function
\lstinline{std::io::stdin()}. This provides a handler for reading from the
terminal input.

Specifically, reading a line from the terminal input can be done by calling the
\lstinline{read_line(&mut <arg>)} function on an instance of
\lstinline{std::io::Stdin} where the argument is a reference to a variable that
the line will be read into. Remember that since the argument needs to be
modified to contain the string, it must be explicitly declared mutable.

\section{Result types and Error handling}

Rust uses Result types to encode error handling information. The Result type
itself is an enum with two variants Ok, and Err. Using Result types effectively
forces you to write error handling code as the compiler will complain at you
with warnings.

For a specific example, the \lstinline{std::io::stdin().read_line(&mut <arg>)}
returns a Result value of a specific type \lstinline{io::Result}. These Result
types may have methods defined on them and in this particular case the
\lstinline{.expect(<String>)} method will print the given string argument if
the Result type is of an Err variant.

\section{The println! Macro}

The \lstinline{println!} macro allows you to use placeholders in the form of
curly braces within the string. These placeholders then get replaced with the
value of the supplied variables in the order in which they appear. For example:

\begin{lstlisting}
println!("This is placeholder {}, {}", 1, 2);

// outputs "This is placeholder 1, 2"

\end{lstlisting}

\subsection{Marco not function}

the println! is not a function but a macro. Macros are specified with an
exclamation point ``!''.

\section{Documentation}

To open and read documentation for the crate and it's dependencies you can run
the command \lstinline{cargo doc --open} which will build and show the
documentation.

\section{Match expressions and comparators}

Every type that can be compared has a \lstinline{.cmp()} method that returns a
\lstinline{std::cmp::Ordering} type. This can be one of three variants:
\lstinline{Ordering::Less}, \lstinline{Ordering::Greater}, and
\lstinline{Ordering::Equal}.

A match expression is similar to a switch statement in other languages and will
check the value against its \emph{arms} and then execute the appropriate code.
For example:

\begin{lstlisting}
match numbera.cmp(&numberb) {
    Ordering::Less => println!(``Number A < Number B''),
    Ordering::Greater => println!(``Number A > Number B''),
    Ordering::Equal => println!(``Number A = Number B''),
}
\end{lstlisting}

However, match expressions are much more powerful than simple switch statements
and can be used to ensure that you are handling a whole variety of situations
that can arise.

\subsection{Error handling with match expressions}

Since the \lstinline{Result} type is an enum containing \lstinline{Ok} and
\lstinline{Err} types, you can use a \lstinline{match} expression to replace an
\lstinline{expect} method and do more fine-grained processing of errors. In
this case the arms of the expression become the types \lstinline{Ok} and
\lstinline{Err}.

For example, trying to parse a string into an integer you can use the
following:

\begin{lstlisting}
let five = "a 5"
let five: u32 = match five.trim().parse() {
    Ok(num) => num,
    Err(_) => { //do something },
}
\end{lstlisting}

The underscore is a wildcard that will match any value, but not bind to it
(meaning you won't be able to use the underscore in an expression).


\section{Type Conversions}

\subsection{String to Unsigned 32-bit Integer}

Strings in Rust feature a \lstinline{parse} function to convert strings to
whatever the inferred type is. However, parsing strings can also result in
failure and as such you should use the \lstinline{expect} method on the
\lstinline{parse} method.

It is also wise to use \lstinline{trim()} on strings to ensure that leading and
trailing whitespace is removed before attempting to parse an integer.

For example converting the string \lstinline{five = "5"} to an integer you can
do the following.

\begin{lstlisting}
let five: u32 = five.trim().parse()
    .expect("Failed to parse string!")
\end{lstlisting}

\section{Variable Shadowing}

Rust uses type inference to determine --- at compile time --- what the types
are of the variables. However, it also allows variable names to be reused even
in the same scope and ``shadow'' the other variable declarations and
assignments. This is useful when doing type conversions without having to
declare additional variable names.



\section{Loops!}

For the simplest of loops, using the \lstinline{loop} syntax creates and
infinite loop. You can then use the controls of \lstinline{break} and
\lstinline{continue} within the loop or to exit.


\end{document}
