\documentclass[12pt,notitlepage]{article}

\usepackage{hyperref}
\hypersetup{colorlinks = true, linkcolor = blue}

\usepackage{graphicx}
\graphicspath{{.images/}}

\usepackage{listings}
\usepackage{color}

\definecolor{mygray}{rgb}{0.5,0.5,0.5}


\lstset{basicstyle=\footnotesize\ttfamily}

% To use glossaries uncomment below

%\usepackage[toc]{glossaries}
%\makeglossaries
%\include{<glossaryfilename>}

\begin{document}

\title{Rust Programming Language}
\author{}
\date{}
\maketitle

%\tableofcontents
%\newpage

These notes are made from studying this
\href{https://doc.rust-lang.org/book/title-page.html}{book} 

\section{Hello World}

All Rust programs must feature a main function defined by

\begin{lstlisting}
fn main() {}
\end{lstlisting}


\subsection{Compilation}

Compiling is done using the rustc command and supplying the file containing the
main function

\section{Cargo}

Cargo is a useful tool for project creation and dependency management.

\subsection{Starting new projects}

Using \lstinline{cargo new <name>} automatically creates a new dir and
initialises a git repo in it. In the new repo you will find the following:

\begin{itemize}
    \item Cargo.toml
    \item .gitignore
    \item src
        \begin{itemize}
            \item main.rs
        \end{itemize}
\end{itemize}

\subsection{Cargo.toml}

The Cargo.toml file is a configuration file for the project written in Toms
Obvious Minimal Language.

It specifies a Rust package or \emph{crate}.

Cargo expects all code to live within the src directory and all of the
configuration, README, and licenses to live in the top-level directory.

\subsection{Building with Cargo}

Cargo has three different commands to check, build, and run the Rust code
called \lstinline{check}, \lstinline{build}, and \lstinline{run}.

Cargo check doesn't actually build a runnable executable, but does a quick
check to see if your code will compile. Build on the other hand actually
creates a binary executable and places it in the target/debug folder. Finally,
run builds and then runs the code from the target/debug folder.

Should you wish to release a binary executable, adding the flag
\lstinline{--release} to the build command will build a release version that
has been optimised thoroughly.

%\appendix




\subsection{Adding Dependencies}

With the Cargo.toml file you can easily add library crates to your project by
listing them under the ``dependencies'' section. It is necessary to specify the
crate name as well as providing a \emph{semantic version} number. For example,
if we were to add the \lstinline{rand} library we could do it like this:

\begin{lstlisting}
[dependencies]

rand = "0.3.14"
\end{lstlisting}

When this has been added to the Cargo.toml file, running build, check, or run
will cause cargo to automatically look up the rand library on the crates.io
registry. Then it'll pull the library as well as any of its dependencies before
compiling your crate.


\subsection{Updating dependency versions}

Running \lstinline{cargo update} will ignore the Cargo.lock file and attempt to
update the version number of the dependencies. However, it will only update the
patch versions and not the minor versions. For example, given a version 1.2.1
and there are two new versions 1.2.2 and 1.3.0. Cargo will update to 1.2.2 and
not 1.3.0 because it will not automatically bump the minor version number.
Therefore, you need to manually bump any dependencies if you wish to use a
newer minor/major version.

\subsection{Cargo.lock file}

For people familiar with the Python Pip system, the Cargo.lock file works
similarly to a requirements.txt, but is created and maintained automatically by
cargo. When the crate is first built it will ``lock'' all of the versions for
the dependencies which ensures that the crate will always build regardless of
the dependencies updating with breaking changes. These versions will not update
unless you explicitly run \lstinline{cargo update} or manually edit the
versions in the Cargo.toml file.


\section{Variables and Constants}

\subsection{Variable Assignment and Referencing}

Variables and references are immutable by default. Variable assignment is
achieved by using the \lstinline{let} keyword. Should you want a mutable
variable you add the \lstinline{mut} keyword after \lstinline{let} but before
the variable name. For example:

\begin{lstlisting}
let steadfast = true; //immutable

let mut wavering = true; //mutable
wavering = false;

\end{lstlisting}

Similarly, references are also immutable by default.

\begin{lstlisting}
&wavering // immutable

&mut wavering // mutable
\end{lstlisting}

It is important in Rust to be judicious in the use of mutability. There are
trade-offs to be made with respect to efficiency, debugging, code legibility, and
maintenance. For example, it might be more efficient to modify a large data
structure in place than creating a new updated copy. On the other hand, if the
data is small enough, it would probably be easier to read by creating new
instances of the data structure that also avoids any unwanted mutability.

\subsubsection{Specifying type}

A specific type for a variable can be denoted using the \lstinline{:}
syntax. For example declaring a unsigned 32-bit integer looks something like
this:

\begin{lstlisting}
let x: u32 = 1
\end{lstlisting}




\subsection{Variable Shadowing}

Rust uses type inference to determine --- at compile time --- what the types
are of the variables. However, it also allows variable names to be reused even
in the same scope and ``shadow'' the other variable declarations and
assignments. This is useful when doing type conversions without having to
declare additional variable names.


\subsection{Type Conversions}

\subsubsection{String to Unsigned 32-bit Integer}

Strings in Rust feature a \lstinline{parse} function to convert strings to
whatever the inferred type is. However, parsing strings can also result in
failure and as such you should use the \lstinline{expect} method on the
\lstinline{parse} method.

It is also wise to use \lstinline{trim()} on strings to ensure that leading and
trailing whitespace is removed before attempting to parse an integer.

For example converting the string \lstinline{five = "5"} to an integer you can
do the following.

\begin{lstlisting}
let five: u32 = five.trim().parse()
    .expect("Failed to parse string!")
\end{lstlisting}




\subsection{Constants}

While variables in Rust are immutable by default, there are also constants
which are always immutable. Furthermore, constants have the following
constraints:

\begin{itemize}
    \item declared using \lstinline{const} keyword
    \item type must be annotated
    \item may only be set to a constant expression
\end{itemize}

That last point means that the constant cannot be assigned to the result of a
function or another any value that is computed at runtime.

Rust convention is to name constants with all uppercase and underscores between
words.

\begin{lstlisting}
const MAX_POINTS: u32 = 100_000;
\end{lstlisting}

\subsubsection{Scope \and Shadowing}

Constants are valid for the entire time the program runs within their declared
scope. Furthermore, constants may be declared in the global scope so as to be
accessible to the entirety of the Rust program.

That also means that a constant, once declared, cannot be shadowed by another
variable. Instead the compiler will complain that the variable name was instead
interpreted as a constant pattern. This does not apply to shadowing a constant
with a constant in a different scope as can be seen below.

\begin{lstlisting}
const MAX_POINTS: u32 = 100_000;

fn main() {
    
    const MAX_POINTS: u32 = 200_000;

    println!("{}", MAX_POINTS);

}
\end{lstlisting}

The following code will print \lstinline{200000} although the compiler will warn
that the outer scoped \lstinline{MAX_POINTS} is unused.

It should be noted however, that constants are used in the scope that they are
declared in. For example, if we had a function that makes use of our constant
and then call in in a scope where the constant was shadowed, it will use the
unshadowed constant. See the example below.

\begin{lstlisting}
const MAX_POINTS: u32 = 100_000;

fn main() {
    
    const MAX_POINTS: u32 = 200_000;

    println!("{}", MAX_POINTS);

    print_points();
}

fn print_points() {

    println!("{}", MAX_POINTS);

}
\end{lstlisting}

The following will first print \lstinline{200000} followed by
\lstinline{100000} since the function \lstinline{print_points} makes use of the
globally scoped constant and not the locally scoped constant.

\section{Associated functions}

The double colon syntax denotes calling an \emph{associated function} meaning
it is linked to a type and not an instance. That also means it does not need an
instance to be called. For example, the \lstinline{String} type has an
associated function \lstinline{::new()} which returns a new instance of the
string type.

\section{Reading from \lstinline{stdio}}

The standard library contains an io module which can be used to create an
instance of \lstinline{std::io::Stdin} by calling the function
\lstinline{std::io::stdin()}. This provides a handler for reading from the
terminal input.

Specifically, reading a line from the terminal input can be done by calling the
\lstinline{read_line(&mut <arg>)} function on an instance of
\lstinline{std::io::Stdin} where the argument is a reference to a variable that
the line will be read into. Remember that since the argument needs to be
modified to contain the string, it must be explicitly declared mutable.

\section{Result types and Error handling}

Rust uses Result types to encode error handling information. The Result type
itself is an enum with two variants Ok, and Err. Using Result types effectively
forces you to write error handling code as the compiler will complain at you
with warnings.

For a specific example, the \lstinline{std::io::stdin().read_line(&mut <arg>)}
returns a Result value of a specific type \lstinline{io::Result}. These Result
types may have methods defined on them and in this particular case the
\lstinline{.expect(<String>)} method will print the given string argument if
the Result type is of an Err variant.

\section{The println! Macro}

The \lstinline{println!} macro allows you to use placeholders in the form of
curly braces within the string. These placeholders then get replaced with the
value of the supplied variables in the order in which they appear. For example:

\begin{lstlisting}
println!("This is placeholder {}, {}", 1, 2);

// outputs "This is placeholder 1, 2"

\end{lstlisting}

\subsection{Marco not function}

the println! is not a function but a macro. Macros are specified with an
exclamation point ``!''.

\section{Documentation}

To open and read documentation for the crate and it's dependencies you can run
the command \lstinline{cargo doc --open} which will build and show the
documentation.

\section{Match expressions and comparators}

Every type that can be compared has a \lstinline{.cmp()} method that returns a
\lstinline{std::cmp::Ordering} type. This can be one of three variants:
\lstinline{Ordering::Less}, \lstinline{Ordering::Greater}, and
\lstinline{Ordering::Equal}.

A match expression is similar to a switch statement in other languages and will
check the value against its \emph{arms} and then execute the appropriate code.
For example:

\begin{lstlisting}
match numbera.cmp(&numberb) {
    Ordering::Less => println!(``Number A < Number B''),
    Ordering::Greater => println!(``Number A > Number B''),
    Ordering::Equal => println!(``Number A = Number B''),
}
\end{lstlisting}

However, match expressions are much more powerful than simple switch statements
and can be used to ensure that you are handling a whole variety of situations
that can arise.

\subsection{Error handling with match expressions}

Since the \lstinline{Result} type is an enum containing \lstinline{Ok} and
\lstinline{Err} types, you can use a \lstinline{match} expression to replace an
\lstinline{expect} method and do more fine-grained processing of errors. In
this case the arms of the expression become the types \lstinline{Ok} and
\lstinline{Err}.

For example, trying to parse a string into an integer you can use the
following:

\begin{lstlisting}
let five = "a 5"
let five: u32 = match five.trim().parse() {
    Ok(num) => num,
    Err(_) => { //do something },
}
\end{lstlisting}

The underscore is a wildcard that will match any value, but not bind to it
(meaning you won't be able to use the underscore in an expression).


\section{Loops!}

For the simplest of loops, using the \lstinline{loop} syntax creates and
infinite loop. You can then use the controls of \lstinline{break} and
\lstinline{continue} within the loop or to exit.


\section{Data Types}

Rust is a statically typed language that is able to infer data types at compile
time. However, sometimes there is ambiguity as to what type should be inferred
and then it is required for the variable to be explicitly annotated with a
datatype. This is particularly true when parsing strings into numerical values
as they can be valid for multiple different types: integer, float, double etc. 

\subsection{Scalar types}

Scalar types, as the name suggests, represent a singular value. Rust has four
primary scalar types:

\begin{itemize}
    \item integer
    \item floating-point
    \item boolean
    \item character
\end{itemize}

\subsubsection{Integers}

Integers are numbers without a fractional component and Rust allows for a
varying number of integer lengths from 8-bit up to 128-bit or whatever the
architecture standard is (specified with \lstinline{isize} and
\lstinline{usize} for signed and unsigned respectively). These integers can
either be signed (allowing for negative numbers) or unsigned (positive numbers
only) by prefixing the integer length with \lstinline{i} or
\lstinline{u} respectively. A breakdown on integer lengths and their type
declarations can be found in Table \ref{tab:int_types}.

\begin{table}
    \centering
    \begin{tabular}{|l|l|l|}
        \hline
        \textbf{Length} & \textbf{Signed} & \textbf{Unsigned} \\
        \hline 
        8-bit & \lstinline[]$i8$ & \lstinline[]$u8$ \\
        16-bit & \lstinline[]$i16$ & \lstinline[]$u16$\\
        32-bit & \lstinline[]$i32$ & \lstinline[]$u32$\\
        64-bit & \lstinline[]$i64$ & \lstinline[]$u64$\\
        128-bit & \lstinline[]$i128$ & \lstinline[]$u128$\\
        arch & \lstinline[]$isize$ & \lstinline[]$usize$\\
        \hline
    \end{tabular}
    \caption{Integer types in Rust}
    \label{tab:int_types}
\end{table}

Integer literals can be written in a variety of ways as well as supporting a
type suffix. The exception to this is the byte literal notation which will
always result in a \lstinline{u8} type. Some examples of the different integer
literals can be found in Table \ref{tab:int_literals}

\begin{table}
    \centering
    \begin{tabular}{|l|l|}
        \hline
        \textbf{Number literals} & \textbf{Example} \\
        \hline
        Decimal & \lstinline[]$98_222$ \\
        hex & \lstinline[]$0xff$ \\
        Octal & \lstinline[]$0o77$ \\
        Binary & \lstinline[]$0b1001_1111$ \\
        Byte (\lstinline[]$u8$ only) & \lstinline[]$ b'A'$ \\
        \hline

    \end{tabular}
    \caption{Integer Literals in Rust}
    \label{tab:int_literals}
\end{table}

Integer overflow in Rust is handled a bit strangely. When compiling in debug
mode, Rust will check for integer overflow and panic if it occurs by exiting
with an error. However, if it is compiled in release mode, Rust will instead
use two's complement wrapping to prevent panics. This is still considered
erroneous since the wrapped value might not have the intended value.

\subsubsection{Floating-Point Types}

The default floating-point size in Rust is 64 bits. Thus, if it is left to the
compiler to infer a floating-point type it will default to a 64-bit float with
\lstinline{f64}.  However, you may explicitly specify a 32-bit float
(\lstinline{f32}) as well. In Rust, a 32-bit float is considered single
precision while a 64-bit float is considered double precision.



\subsection{Compound types}



\end{document}
